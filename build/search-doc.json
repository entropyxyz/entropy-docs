{"searchDocs":[{"title":"Basics","type":0,"sectionRef":"#","url":"/basics/","content":"Basics","keywords":"","version":"Next"},{"title":"Concepts","type":0,"sectionRef":"#","url":"/concepts/","content":"Concepts","keywords":"","version":"Next"},{"title":"Access Modes","type":0,"sectionRef":"#","url":"/concepts/access-modes","content":"Access Modes Entropy accounts can have two distinct access modes. With public access mode, anyone can submit a request to sign a message. However, the account may be configured with a program that restricts who can sign messages or has rules about what kinds of messages different users may sign. Data, such as a signature from the user, may be passed in as auxiliary data to the program. For example, an organization whose members change over time could use public access where signing rules are defined in a program, and the program could be updated whenever the status of group members changes. Adding these constraints to an account are available in every access mode, not just public access. With private access mode, the users themselves hold a key share and participate in the distributed key generation and signing protocols. This is the most secure mode, as it is impossible for the TSS servers to collude against the user. However, it requires that the user safeguard their key share and requires more complicated UX.","keywords":"","version":"Next"},{"title":"Proactive refresh","type":0,"sectionRef":"#","url":"/concepts/proactive-refresh","content":"Proactive refresh The concept here is that as validators enter and exit the network, their key shares should become invalid. Every session (2400 blocks, which is 4 hours), the chain will inform the TSS servers that a proactive refresh is happening. The network (registered keys) will be partitioned so as not to refresh the whole network and cause undue strain on the validators. One TSS server from each subgroup is selected deterministically using the current block number modulo the number of TSS servers in that subgroup, similar to the selection process for DKG when registering. The selected TSS servers (one in each subgroup) will connect to each other and run the proactive refresh protocol, producing a new set of key shares. The protocol is similar to the distributed key generation protocol used during registration. The selected TSS servers send the new key shares to the other members of their subgroup, and on receiving a key share, they replace their existing key share in their key-value store with the new one. All old key shares will now be incompatible with the refreshed key shares. However, the public validating key of the distributed signing keypair never changes. The private access mode, an individual trigger will exist where it is initiated by the user (not yet implemented).","keywords":"","version":"Next"},{"title":"Joining the network","type":0,"sectionRef":"#","url":"/concepts/joining-the-network","content":"","keywords":"","version":"Next"},{"title":"Information needed from a Validator to join the network​","type":1,"pageTitle":"Joining the network","url":"/concepts/joining-the-network#information-needed-from-a-validator-to-join-the-network","content":" Endpoint - The IP address of its threshold serverX25519PublicKey - Its public encryption key for encrypting messages to and from other validatorsThreshold Server Signing Account - Account for the threshold server to submit transactions to the Entropy chain ","version":"Next","tagName":"h2"},{"title":"Node encryption and authentication","type":0,"sectionRef":"#","url":"/concepts/node-encryption-and-authentication","content":"Node encryption and authentication When sending messages to threshold signature servers on the Entropy network, you must authenticate and encrypt the messages. The authentication process is simple: each node has a substrate account stored on the chain, referred to as a TSS account. Messages are signed using SR25519. This encryption requires using an X25519 public key which gets used in Hybrid Public Key Encryption, using the hpke-rs crate. By combining the two, we can generate an EncryptedSignedMessage. JavaScript bindings for creating these are available in the entropy-protocol-nodejs and entropy-protocol-web modules. The concept is simple: Whenever you need to authenticate a party, you use a substrate key that is associated with them, whether it's a user submitting an extrinsic or a node with a TSS account.When encrypting a message (only when communicating with nodes), you use their public key to create an encrypted message using HPKE.","keywords":"","version":"Next"},{"title":"Support","type":0,"sectionRef":"#","url":"/basics/support","content":"","keywords":"","version":"Next"},{"title":"1. Check the documentation​","type":1,"pageTitle":"Support","url":"/basics/support#1-check-the-documentation","content":" Before submitting an issue, search the Entropy Docs and associated resources. This seems obvious, but it's often worth throwing your question into the search bar.  ","version":"Next","tagName":"h2"},{"title":"2. Identify the issue​","type":1,"pageTitle":"Support","url":"/basics/support#2-identify-the-issue","content":" Clearly define the problem you're encountering with the Entropy network.Gather relevant details like error messages, logs, and steps to reproduce the issue.  ","version":"Next","tagName":"h2"},{"title":"3. Search for existing issues​","type":1,"pageTitle":"Support","url":"/basics/support#3-search-for-existing-issues","content":" Utilize the search function within Entropy Docs GitHub Issues to see if your problem has already been reported.Look for issues with similar descriptions or error messages.If a relevant issue exists, check for comments or solutions and consider contributing to the existing discussion instead of creating a new issue.  ","version":"Next","tagName":"h2"},{"title":"4. Create a new issue​","type":1,"pageTitle":"Support","url":"/basics/support#4-create-a-new-issue","content":" If no existing issue matches your problem, create a new issue.Provide a clear and concise title for your issue.Follow the issue template for instructions.  ","version":"Next","tagName":"h2"},{"title":"5. Submit the issue​","type":1,"pageTitle":"Support","url":"/basics/support#5-submit-the-issue","content":" Once you've completed all the details, proofread your description for clarity and conciseness.Submit the issue and wait for a response.  ","version":"Next","tagName":"h2"},{"title":"6. Follow up​","type":1,"pageTitle":"Support","url":"/basics/support#6-follow-up","content":" Monitor the issue for updates and promptly respond if we ask further questions.Consider mentioning the solution in the comments section of similar issues once your issue gets resolved.  ","version":"Next","tagName":"h2"},{"title":"Additional tips​","type":1,"pageTitle":"Support","url":"/basics/support#additional-tips","content":" Be specific and transparent about the problem you're facing. The more details you provide, the easier it will be for the maintainers to diagnose and address the issue. ","version":"Next","tagName":"h2"},{"title":"Signing","type":0,"sectionRef":"#","url":"/concepts/signing","content":"","keywords":"","version":"Next"},{"title":"Signing process​","type":1,"pageTitle":"Signing","url":"/concepts/signing#signing-process","content":"   The user computes the hash of the message they wish to sign and selects a signing committee by deterministically selecting a member of each signing group based on this hash. They can get the details of the signing groups as they were published on-chain when the user registered.The user contacts all threshold servers in the signing committee and makes a POST to /user/sign_tx with the message to be signed (encrypted for that node).On receiving a message, each node checks that it is a member of the signing committee for that message using the hash.The Threshold server retrieves the latest version of the associated program from the entropy chain, and executes it with the message to be signed as input. Only on getting successful program output do they continue to the next step.The Threshold server sets up websocket connections to or from the rest of the committee to use for threshold signing protocol messages. They decide whether to make an outgoing connection, or accept an incoming one by comparing account IDs. These connections are secured using the noise protocol. Signing protocol messages can be either 'broadcast' to all of the committee or 'p2p' to a specific member.Once all members of the signing committee have subscribed, nodes participate in the signing protocol to produce a signature using the key-shares retrieved from their key-value store.If the signing process fails, nodes broadcast who the malicious/faulty signer was, which is included in the next block. Following that, the next block contains details of a new signing committee. The misbehaving signer will be 'slashed' (not yet implemented).If the process is successful, the signature is returned to the user. Currently, this requires the user to repeatedly poll POST signer/signature with the signature hash until it successfully retrieves a signature.  ","version":"Next","tagName":"h2"},{"title":"Signing Group Selection​","type":1,"pageTitle":"Signing","url":"/concepts/signing#signing-group-selection","content":" Signing groups are chosen and held on-chain. Every time a new validator joins or gets removed, the chain will place or remove them from a subgroup such that:  Subgroups do not shuffle current validators.Subgroups remain the same size or off by one. ","version":"Next","tagName":"h2"},{"title":"Glossary","type":0,"sectionRef":"#","url":"/basics/glossary","content":"","keywords":"","version":"Next"},{"title":"Account​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#account","content":" All of the information associated with a specific program for a particular user or entity. An account is established with an admin key. An admin key can assign capabilities to device keys.  ","version":"Next","tagName":"h2"},{"title":"Admin key​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#admin-key","content":" A key that allows you to deploy programs and modify the settings of those programs. Admin keys cannot request signatures. This key must be funded in order to perform some actions.  ","version":"Next","tagName":"h2"},{"title":"Adapter​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#adapter","content":" Plugins that provide support for different chains and program configurations. For example, an adapter can be used to define a specific hashing function to use when signing. Different chains have different signing algorithms; this allows us to support them all.  ","version":"Next","tagName":"h2"},{"title":"Application chain​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#application-chain","content":" A blockchain that is exclusively designed for a single application, unlike a public blockchain designed for multiple apps. Also called an application-specific blockchain, or appchain.  ","version":"Next","tagName":"h2"},{"title":"Autonomous agent​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#autonomous-agent","content":" A program designed to act independently, capable of executing tasks and making decisions based on predefined rules or algorithms. Autonomous agents are seen as key players in the evolution towards digital environments where AI and blockchains intersect, often called autonomous worlds.  Autonomous agents are sometimes also called intelligent programs.  ","version":"Next","tagName":"h2"},{"title":"Consumer key​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#consumer-key","content":" A synonym for a device key or deploy key.  ","version":"Next","tagName":"h2"},{"title":"Device key​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#device-key","content":" A key that can request signatures from Entropy Programs. By default, device keys cannot install Programs or modify the settings of Programs. However, Programs can be given admin-key privileges. A device key does not need to hold funds in order to perform actions.  ","version":"Next","tagName":"h2"},{"title":"Entropy chain​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#entropy-chain","content":" An application-specific layer 1 blockchain with the purpose of coordinating distributed signing.  ","version":"Next","tagName":"h2"},{"title":"Entropy network​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#entropy-network","content":" The set of Entropy validators.  ","version":"Next","tagName":"h2"},{"title":"Intelligent program​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#intelligent-program","content":" A synonym for an autonomous agent.  ","version":"Next","tagName":"h2"},{"title":"Partition​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#partition","content":" Also called a signing subgroup. A set of threshold signing servers that all hold identical keyshares. To sign a message, one member of each subgroup must participate. The Entropy chain is responsible for assigning new threshold signing servers to a subgroup.  ","version":"Next","tagName":"h2"},{"title":"Program​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#program","content":" The logic defining what conditions a threshold signing server (TSS) should participate in signing a particular transaction or message. Programs are compiled into WebAssembly blobs that are uploaded to the blockchain, and can be updated by subsequent authenticated, valid transactions.  Programs run when a device key requests a signature from the Program. Each Program returns true or false. If the Program returns true, the Entropy Network executes signing, and a signature is returned to the requesting device key.  ","version":"Next","tagName":"h2"},{"title":"Program developer​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#program-developer","content":" Refers to the human or humans using the Entropy Network to build and deploy programs.  ","version":"Next","tagName":"h2"},{"title":"Program dev key​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#program-dev-key","content":" An authorization key that permits its holder to deploy Programs for installation onto the Entropy blockchain by admin keys. Program dev keys do not need to be registered.  ","version":"Next","tagName":"h2"},{"title":"Registration​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#registration","content":" The process of establishing an Entropy account. Registered accounts can be initialized with Programs and modify those Programs later.  ","version":"Next","tagName":"h2"},{"title":"Signature request account​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#signature-request-account","content":" The account on the Entropy chain that is used to initiate signature requests.  ","version":"Next","tagName":"h2"},{"title":"Signing committee​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#signing-committee","content":" A set of threshold signing servers that have been selected to participate in signing a particular message. This is composed of validators from different signing subgroups.  ","version":"Next","tagName":"h2"},{"title":"Signing subgroup​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#signing-subgroup","content":" A set of threshold signing servers that all hold identical keyshares. To sign a message, one member of each subgroup must participate. The Entropy chain is responsible for assigning new threshold servers to a subgroup.  A signing subgroup is also called a partition.  ","version":"Next","tagName":"h2"},{"title":"SS58​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#ss58","content":" The default Substrate address format. The SS58 encoded address format is based on the Bitcoin Base-58-check format but with a few modifications specifically designed to suit Substrate-based chains.  ","version":"Next","tagName":"h2"},{"title":"TSS account​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#tss-account","content":" A threshold signature server account is the identifier for an Entropy chain account belonging to a given threshold signing server. These servers are sometimes referred to as threshold signing servers.  ","version":"Next","tagName":"h2"},{"title":"Threshold signing​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#threshold-signing","content":" A cryptographic technique that allows a group of participants to collectively produce a digital signature on a message without any single participant having access to the complete private signing key. The private signing key is divided into multiple shares, with each participant holding one share. To produce a valid signature, a predetermined threshold number of shares (e.g., 3 out of 5) must be combined. This way, no single entity possesses the entire private key.  ","version":"Next","tagName":"h2"},{"title":"Threshold server​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#threshold-server","content":" An instance of the Entropy threshold signature server.  ","version":"Next","tagName":"h2"},{"title":"Transaction​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#transaction","content":" A transaction is a discrete request submitted for inclusion on the Entropy blockchain containing a Program or account registration, modification, or other arbitrary data that a user such as a program developer or autonomous agent wants to have signed and validated by the Entropy Network.  ","version":"Next","tagName":"h2"},{"title":"User​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#user","content":" Refers to whoever is using the Entropy network to sign transactions or messages. This may be an individual, an organisation, or some other entity.  ","version":"Next","tagName":"h2"},{"title":"Validator​","type":1,"pageTitle":"Glossary","url":"/basics/glossary#validator","content":" A device running both an Entropy chain node, and a threshold signing server. ","version":"Next","tagName":"h2"},{"title":"Registering","type":0,"sectionRef":"#","url":"/concepts/registering","content":"","keywords":"","version":"Next"},{"title":"The registering process​","type":1,"pageTitle":"Registering","url":"/concepts/registering#the-registering-process","content":"   The user registers with the Entropy chain by submitting a transaction from the 'signature request account' containing the 'Account Key', initial 'ProgramsData', and chosen access mode. ProgramsData - Is multiple Programs Instances. Which contain the program_pointer (the hash of the program you want to use) and the program_config for that program. On the evaluation of a signature request a threshold server will run all the programs and pass through the program config for that program. The chain selects which nodes should perform a distributed key generation (DKG) based on the current block number. As each block is finalized, an off-chain worker makes an HTTP POST request to each selected threshold server with the signature request accounts of all users who have registered, as well as details of the other validator nodes in the signing subgroup. Specifically, the /user/new (src API) endpoint is called with a OcwMessageDkg. All selected threshold servers: Connect to each other over websocket and make a noise handshake to establish an encrypted channel for protocol messages.Perform a DKG and store their key-share in their encrypted key-value store.Send the generated share to other members of their signing subgroup by POSTing to /user/receive_key (src API).They submit a transaction to the entropy chain to confirm the user has successfully registered. On receiving a key-share via receive_key, the threshold server will check with the chain that the sender is in the correct subgroup, and if so store the key-share in their key-value store. On receiving a confirmation transaction from all selected threshold server, the chain sets the user to a 'registered' state, making it possible to sign messages. ","version":"Next","tagName":"h2"},{"title":"Programs","type":0,"sectionRef":"#","url":"/concepts/programs","content":"","keywords":"","version":"Next"},{"title":"Features and details​","type":1,"pageTitle":"Programs","url":"/concepts/programs#features-and-details","content":" More concretely, they are WebAssembly components that implement an Entropy-specific interface. The only function a user must manually implement is evaluate, which takes the user's signature request as input and returns it as successful or an error. If no error is returned, then the message in the signature request will be signed using the program's corresponding key pair with the specified hashing algorithm.  ","version":"Next","tagName":"h2"},{"title":"Custom Hashing​","type":1,"pageTitle":"Programs","url":"/concepts/programs#custom-hashing","content":" As ECDSA schemes sign 256-bit numbers, programs can include a custom_hash function so users can utilize less common hashing functions. In its simplest form, the function converts a signature request (which also contains the message) into a 256-bit number.  An example of a custom hash implementation is available in the entropyxyz/programs repository.  The list of natively supported hashing algorithms can be found within the entropyxyz/entropy-core repository.  ","version":"Next","tagName":"h3"},{"title":"Program Configs​","type":1,"pageTitle":"Programs","url":"/concepts/programs#program-configs","content":" Programs can include a configuration, which allows users to modify the evaluation behavior without having to recompile and upload a new program to the chain. The format of this is undefined, allowing a configuration to be defined as a serialized C-compatible struct, UTF-8 JSON string, or anything in between.  An example of a program that uses a config can be found within the entropyxyz/programs repository. In this example; the user specifies an allow-list of Ethereum recipients using a JSON string config.  ","version":"Next","tagName":"h3"},{"title":"Auxiliary Data​","type":1,"pageTitle":"Programs","url":"/concepts/programs#auxiliary-data","content":" Programs can require users to include auxiliary data, separate from the message, in their signature request. An example of a program that requires a zero-knowledge proof as auxiliary data can be found within the entropyxyz/programs repository.  ","version":"Next","tagName":"h3"},{"title":"Upload Programs​","type":1,"pageTitle":"Programs","url":"/concepts/programs#upload-programs","content":" Programs are written and compiled to WASM using the entropyxyz/programs repository.  The workflow is as follows:  A program owner calls set_program in the program pallet with the program bytecodethe configuration interface which is a seralized json object that allows a user to know the configuration of the program then set their own indiviudualized configuration in programsDataThe signing key signs the tx and becomes the deployer keyA ref counter gets set to 0 when uploading and is used to track how many users are using a program A program then gets stored in the Programs storage slot with the key being H(bytecode + configuration_interface). The hash is used by a user to point to the programs they want applied to their key, everytime a program is referenced the ref counter incrementsSince the key is a hash there is no editing programs (since that would change the hash)Programs can be removed if the ref count is zero by the deploy key ","version":"Next","tagName":"h2"},{"title":"Entrosplainer","type":0,"sectionRef":"#","url":"/basics/entrosplainer","content":"","keywords":"","version":"Next"},{"title":"Asset Custodian? 👉️👈️​","type":1,"pageTitle":"Entrosplainer","url":"/basics/entrosplainer#asset-custodian-️️","content":" An asset custodian is a service that holds your funds, like a wallet. The &quot;you&quot; in this case could be just you, or it could be you and a whole organization. An asset custodian should be able to do a couple of things that most wallets can't:  You may have funds across multiple addresses, and maybe across multiple chains. An asset custodian should be a single interface between you and all of these accounts. We call the capacity to interoperate with all chains being chain agnostic.An asset custodian should be able to represent multi-user accounts: accounts with shared access by multiple parties. The permissions for each of these parties may be different. Some transactions may require multi-user sign-off, as in a multisignature.A user should be able to specify arbitrary constraints on how funds move through the custodian. Features like per-user time-bound spending limits, time-locked transactions, and how each user interacts with the custodian should be able to be flexibly set by the user or organization.The custodian should be well-secured, while anticipating the need for emergency scenarios for secure account recovery.  We further believe that services should be censorship resistant, credibly neutral, and transparent to users. We believe that decentralization is the only effective way to guarantee these properties. Eliminating centralized intermediary service providers reduces the ways for services to become targets for manipulation and attack.  Smart contract applications achieve decentralization by delegating the execution of application logic to a set of decentralized service providers: miners or validators, or more generally, nodes.  Smart contracts are very powerful primitives for building decentralized applications. But smart contracts are limited to the set of operations exposed by the smart contract infrastructure. Smart contracts typically cannot do any of the following things:  Instruct nodes to make calls outside the network (chain)Hold private stateCheaply perform computation-intensive operations, like those often required by cryptographyAutomate recurring or scheduled computationChange or update rules for how to execute themselves; upgradeable contracts solve this but create other problemsChange properties of the underlying network (block times, transaction subsidy rules, privacy features, etc.)  The construction of a Chain-Agnostic Decentralized Asset Custodian relies on these features. Since platforms providing smart contracts lack these features, Entropy would be impossible to construct on a smart contract platform. This is why we need to build our own chain.  But building our own chain requires us to consider how we will achieve decentralization. Decentralization is a complex topic, and some application chains have been accused of being very not-decentralized. Let's unpack that next.  ","version":"Next","tagName":"h2"},{"title":"But is it Decentralized AF?**​","type":1,"pageTitle":"Entrosplainer","url":"/basics/entrosplainer#but-is-it-decentralized-af","content":" Smart contracts share security and decentralization properties with the underlying network. The most basic metric for decentralization is node count. At the time of writing (August 2023), there are about 14,700 Ethereum nodes, and 16,000 Bitcoin nodes. However, because each infrastructure provider is only minimally incentivized, the Ethereum and Bitcoin networks rely on pooled node operators. In recent events, a particular smart contract has been heavily censored on the Ethereum network, as pooled node operators refuse to include transactions involving the smart contract.  Application chains tend to have fewer nodes than general smart contract platforms. But there is an advantage in finding a middle ground: node operators actually run their own nodes. Decentralization is not a monolithic property; attempting to increase node count arbitrarily can ironically decrease the decentralization of a network by, perversely, incentivizing consolidation. By finding a middle ground in node count, a network can avoid the situation where nodes have consolidated into 3 node pools controlling over 50% of a network's resources, for example.  The Entropy Network will stay at a size which provides for a variety of independent validators while maintaining signing performance. Besides decentralization, there are other reasons we would intentionally choose to keep the node count in this middle ground.  Because Entropy's nodes hold onto shares of private user information (more on that in the next section), there are strong anti-incentives in allowing nodes to join and leave the network frequently. For these reasons, the number of nodes on the Entropy Network needs to be high enough to guarantee decentralized service, but not so high as to misalign the incentives of Entropy validators against users.  We're going to shift attention now to how Entropy works.  ","version":"Next","tagName":"h2"},{"title":"Hello, I would like one cryptography​","type":1,"pageTitle":"Entrosplainer","url":"/basics/entrosplainer#hello-i-would-like-one-cryptography","content":" The easiest way to explain a Threshold Signature Scheme (TSS) is to start with a multisignature.  A $t$-of-$n$ multisignature is a way for $t$ (threshold) participants out of $n$ possible participants to construct a valid signature.  Each participant signs a message with their private key. A trusted centralized coordinator verifies that the $t$ signatures are valid. In blockchain contexts, the central coordinator is typically spelled &quot;smart contract.&quot;    2-of-3 Multisignature  Similarly, a $t$-of-$n$ TSS is a way for $t$ participants out of $n$ possible participants to construct a valid signature, but without a centrally trusted coordinator.  Participants in a threshold signature scheme don't hold onto independent private keys. Before a signature can be constructed, a set of key-shares is generated. This is done either by a process of Distributed Key Generation (DKG) that all parties participate in, or by a Centralized Key Generation process where a single party splits a private key into shares and distributes them to the other parties. Distributed key generation processes have the advantage that every party contributes randomness to generate the private key, but no party has knowledge of the shared private key. A threshold signature scheme constructs valid signatures despite the fact that no party has knowledge of this shared private key.  Threshold signatures schemes eliminate the requirement for a trusted coordinator, and are a powerful and flexible cryptographic primitive.    2-of-3 Threshold Signature Scheme  In the Entropy scheme, key shares are generally custodied by nodes on the Entropy Network, while with Entropy's private access mode, the user holds onto one or more key shares.  Much like a multisignature, the Entropy Network is a decentralized intermediary between users and their funds. But, unlike a multisignature, Entropy can represent and custody funds sitting on any other blockchain, without complicated cross-chain communication. Here's how.  ","version":"Next","tagName":"h2"},{"title":"Entropy in 3️⃣0️⃣ seconds 🕐️​","type":1,"pageTitle":"Entrosplainer","url":"/basics/entrosplainer#entropy-in-3️⃣0️⃣-seconds-️","content":" Alice, a user or organization, wants to construct a transaction for chain X, from her Entropy-managed account.  Alice gets the list of threshold signing servers who have her key-shares from the Entropy chain.A signing committee is selected from this list based on the hash of the particular message she wants to sign.Alice makes a request to each member of the signing committee containing the transaction or message she wants to sign, asking the Entropy Network to consult the Program and construct a signature.Each of these threshold signing servers retrieves the latest version of the associated Program from the Entropy chain and executes it with the message to be signed as input.If the Program returns success, the threshold signing servers in the signing committee connect to each other and execute the threshold signing protocol, producing a valid signature.If the signature fails, the signers are able to prove the identity of the malicious co-signer. This proof can be published in the next block as a slashing-attestation for that node, and a new signing party may be selected.The Entropy front end asks Alice to confirm before submitting the transaction to chain X, at which point it is submitted as a normal transaction on chain X.  The scope of the Entropy Network is well-constrained: check validity, allow users to adjust the definition of validity, and construct signatures over valid messages.  Because threshold signature schemes can be performed &quot;off-chain&quot; (from the perspective of the transaction endpoint) while still producing a valid signature, the final transaction is much less expensive than a smart contract call. The scheme is also credibly decentralized. Unlike centralized custody solutions, the Entropy Network distributes responsibility for operating the custodian. Additionally, the network can elegantly represent accounts on any other chain without relying on expensive cross-chain communication.  ","version":"Next","tagName":"h2"},{"title":"Wrap up​","type":1,"pageTitle":"Entrosplainer","url":"/basics/entrosplainer#wrap-up","content":" So, yeah. In this 'splainer we tried to unpack:  The distinction between the Entropy signing protocol and the application-level programs which determine what can be signed.The different access modes associated with these programs.A decentralized asset custodian as an initial use-case, and how it relates to a wallet or a multisignature.How application chains can achieve decentralization, despite smaller node pools.How threshold signature schemes (TSS) as implemented by threshold signing servers (also, TSS) differ from multisignatures.How the Entropy Network will work, as a new kind of decentralized infrastructure for securing your funds.  Keep an eye out for our upcoming testnet release! ","version":"Next","tagName":"h2"},{"title":"Guides","type":0,"sectionRef":"#","url":"/guides/","content":"Guides","keywords":"","version":"Next"},{"title":"Threshold Signature Scheme","type":0,"sectionRef":"#","url":"/concepts/threshold-signature-scheme","content":"","keywords":"","version":"Next"},{"title":"Features of CGGMP21​","type":1,"pageTitle":"Threshold Signature Scheme","url":"/concepts/threshold-signature-scheme#features-of-cggmp21","content":" ","version":"Next","tagName":"h2"},{"title":"Identifiable aborts​","type":1,"pageTitle":"Threshold Signature Scheme","url":"/concepts/threshold-signature-scheme#identifiable-aborts","content":" 'Identifiable aborts' refers to revealing which party has misbehaved when the signing protocol fails. So, if a party gives faulty or intentionally malicious responses during the signing process, the others can determine who is responsible for the failed signature. In Entropy, the misbehaving party can be made public using Entropy's blockchain, and a new signing committee can be selected for another attempt.  ","version":"Next","tagName":"h3"},{"title":"Non-interactive​","type":1,"pageTitle":"Threshold Signature Scheme","url":"/concepts/threshold-signature-scheme#non-interactive","content":" Only the final round of the signing protocol requires knowledge of the message. The other rounds are known as the 'pre-signing' phase. The paper refers to this as 'non-interactive', as it enables a party to generate its 'signature share' for a given message without interacting with the other parties. The use-case for this is 'cold wallets', which function in isolation. However, to create a 'signature share' from a message, you need the data from the pre-signing stage.  ","version":"Next","tagName":"h3"},{"title":"Few communication rounds​","type":1,"pageTitle":"Threshold Signature Scheme","url":"/concepts/threshold-signature-scheme#few-communication-rounds","content":" The paper proposes two different versions of the protocol, each with a different trade-off between the number of communication rounds needed and the amount of computation required. Either 5 or 8 communication rounds are needed to sign a message, with the 8-round version requiring less computation. However, it is worth noting that the 5-round version's extra computation overhead is only in the case that signing fails. Entropy uses five rounds.  ","version":"Next","tagName":"h3"},{"title":"Proactive security​","type":1,"pageTitle":"Threshold Signature Scheme","url":"/concepts/threshold-signature-scheme#proactive-security","content":" The paper includes a Universally Composable security analysis. The authors claim that 'proactive security' against an adaptive attacker is achieved. An attacker who can control up to $t - 1$ nodes between two consecutive key-refresh phases cannot compromise the scheme.  ","version":"Next","tagName":"h3"},{"title":"Distributed key generation​","type":1,"pageTitle":"Threshold Signature Scheme","url":"/concepts/threshold-signature-scheme#distributed-key-generation","content":" Distributed key generation means parties can compute their key shares without central coordination or the secret key being known to any party.  ","version":"Next","tagName":"h3"},{"title":"Key refreshing​","type":1,"pageTitle":"Threshold Signature Scheme","url":"/concepts/threshold-signature-scheme#key-refreshing","content":" Key shares can be periodically' refreshed' to allow nodes to join or leave the network and provide proactive security. Without changing the secret key, new key shares are generated that are incompatible with the old ones. This can be achieved in three communication rounds.  ","version":"Next","tagName":"h3"},{"title":"Paillier encryption as a commitment scheme​","type":1,"pageTitle":"Threshold Signature Scheme","url":"/concepts/threshold-signature-scheme#paillier-encryption-as-a-commitment-scheme","content":" The protocol uses Paillier encryption, a type of additive homomorphic encryption. Homomorphic encryption refers to encryption schemes that allow computation on encrypted data, which gives an encrypted result without revealing the data or knowing the encryption key. Paillier is 'additive', so given two encrypted numbers and the public key used to encrypt them, we can compute the encryption of their sum without knowing what the numbers were. Also, given an encrypted number, we can compute the encryption of the multiplication of that number by a known number.  Using these primitives, it is possible for two parties, each of which has a secret number, to compute shares of the multiplication of the two secret numbers without learning the other party's secret number. This is referred to in the paper as 'pairwise multiplication'.  So, each party has a Paillier keypair and knows the public keys of the other party. Using this pairwise multiplication technique, all parties are able to contribute or' commit' to the random nonce ($k$ value) used in ECDSA signing and to the signature itself using their private key shares.  ","version":"Next","tagName":"h3"},{"title":"Links to talks​","type":1,"pageTitle":"Threshold Signature Scheme","url":"/concepts/threshold-signature-scheme#links-to-talks","content":" Presentation on the CGGMP21 scheme from Nikolaos MakriyannisPresentation of GG20 (CGGMP21's predecessor) from Steven Goldfelder ","version":"Next","tagName":"h2"},{"title":"Validators","type":0,"sectionRef":"#","url":"/concepts/validators","content":"","keywords":"","version":"Next"},{"title":"The Entropy chain src​","type":1,"pageTitle":"Validators","url":"/concepts/validators#the-entropy-chain-src","content":" The purpose of the Entropy blockchain is to have a 'single source of truth' for the information which needs to be public and which the threshold signature servers need to have consensus on. For example, we need to have agreement of which validators belong to which signing subgroups, and which subgroups will participate in signing a particular message.  ","version":"Next","tagName":"h2"},{"title":"General functionality from Substrate​","type":1,"pageTitle":"Validators","url":"/concepts/validators#general-functionality-from-substrate","content":" Uses the BABE consensus algorithm (Blind Assignment for Blockchain Extension). A brief description of BABE: Time is divided into 'epochs', which consist of a series of 'slots' for each block that will be published.The genesis block contains a random value that determines which nodes will produce blocks during the first two 'epochs'. After that, each epoch uses 'randomness' from two epochs ago in a kind of 'lottery', using a 'verifiable random function' to decide whether a given node may produce a block for a given slot.Some slots have no block producer chosen - in which case a producer is chosen by another selection algorithm - 'round robin'.Some slots have several block producers chosen - in which case all chosen nodes produce a block and there is a 'race' between forks, and the finalisation protocol determines which is kept. Finality is determined by Grandpa (GHOST-based Recursive ANcestor Deriving Prefix Agreement). Finality is the process by which the network agrees that a block will never be reverted.The blockchain runtime compiles to WASM, which allows updates to be published on-chain and carried out automatically without requiring hard forking.Nodes discover each other via libp2p's kademlia DHT.  ","version":"Next","tagName":"h3"},{"title":"Custom functionality specific to Entropy:​","type":1,"pageTitle":"Validators","url":"/concepts/validators#custom-functionality-specific-to-entropy","content":" Staking extension pallet src - staking is extended to assign a particular Threshold Signature Servers account to a particular chain node, and tracks which signing subgroup they belong to.Registry pallet src - This provides a registry of Entropy users and which programs are currently associated with their account. This uses Substrate events.Programs pallet src - This stores program bytecode as well as metadata associated with the program, such as a description of its interface and how many times it is used.  ","version":"Next","tagName":"h3"},{"title":"The Threshold Signature Server src API​","type":1,"pageTitle":"Validators","url":"/concepts/validators#the-threshold-signature-server-src-api","content":" This is the part that carries out the threshold signing protocol, together with other instances of the threshold signature server. It has an encrypted key-value store used for private information where consensus is not required. Since the threshold signature server deals with private data that must never be exposed publicly on-chain, it is distributed as a separate binary. It also handles the distributed key generation and proactive-refresh protocols.  It has the following features:  The signing client src which handles listeners for the different protocol sessions. The protocol transport is handled by the entropy-protocol crate src API, which runs the [ThresholdSignaureScheme].An encrypted key-value store src API for key shares and other secret data, which are submitted by the user. Built with sled.Executes programs - upon which a decision is made as to whether to participate in signing a given message.An HTTP API for communication with users, with the entropy chain node, and with other threshold servers.An account for submitting extrinsic (transactions) to the Entropy chain. For example, when the distributed key generation protocol runs successfully during user registration, each TSS server sends a confirmation to the chain by submitting a transaction.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Validators","url":"/concepts/validators#usage","content":" entropy-tss is a member of the entropy-core workspace. When you run entropy-tss, you will be asked for a password used to encrypt the key-value store.  Be aware there is no way to recover this password if you lose it.  The database is stored in the .entropy directory, which is created in the current working directory where the binary is run. You can remove this directory if you need to 'start fresh' during development.  If entropy-tss is compiled with the unsafe feature enabled, some extra HTTP routes will be made available. These are for testing and development purposes only and allow direct access to the key-value store.  If you need these, build with:  cargo build -p entropy-tss --release --features unsafe ","version":"Next","tagName":"h3"},{"title":"Reference","type":0,"sectionRef":"#","url":"/reference/","content":"Reference","keywords":"","version":"Next"},{"title":"Register an address","type":0,"sectionRef":"#","url":"/guides/register-an-account","content":"","keywords":"","version":"Next"},{"title":"CLI​","type":1,"pageTitle":"Register an address","url":"/guides/register-an-account#cli","content":" Start the CLI by running entropy. At the main menu within the CLI, select Register: ? Select Action Manage Accounts Balance &gt; Register Sign Transfer Deploy Program User Programs Exit The CLI will send your selected account information to the network. As long as you have enough funds in your account, the network will register your account. Attempting to register the address: 5Dcps2RdXPQfiJBxxDnrF8iDzDHcnZC8rb5mcJ3xicqzhYbv Your address 5Dcps2RdXPQfiJBxxDnrF8iDzDHcnZC8rb5mcJ3xicqzhYbv has been successfully registered. Press Y to go back to the main menu.  ","version":"Next","tagName":"h2"},{"title":"SDK​","type":1,"pageTitle":"Register an address","url":"/guides/register-an-account#sdk","content":" The feature is not currently available in the SDK. ","version":"Next","tagName":"h2"},{"title":"Deploy a program","type":0,"sectionRef":"#","url":"/guides/deploy-a-program","content":"","keywords":"","version":"Next"},{"title":"CLI​","type":1,"pageTitle":"Deploy a program","url":"/guides/deploy-a-program#cli","content":" Here is the process for deploying a program using the Entropy CLI.  ","version":"Next","tagName":"h2"},{"title":"Prepare your program​","type":1,"pageTitle":"Deploy a program","url":"/guides/deploy-a-program#prepare-your-program","content":" Before you can upload your program, you'll need the following:  The absolute path of your program (e.g. /home/alex/simple_signer.wasm). The program configuration for your file as a single line of JSON. Configuration files are not mandatory, as not all programs require one. An account with enough funds to deploy your program. In early tests of the Entropy testnet it cost around 2000000000000 bits to deploy a barebones program. Non-registered account It is not necessary to register your account before deploying a program.  Next, you can move on to starting the CLI and deploying your program.  ","version":"Next","tagName":"h3"},{"title":"Deploy the program​","type":1,"pageTitle":"Deploy a program","url":"/guides/deploy-a-program#deploy-the-program","content":" Start the CLI by running entropy. At the main menu within the CLI, select Deploy Program: ? Select Action Manage Accounts Balance Register Sign Transfer &gt; Deploy Program User Programs Exit Select Deploy. Enter the absolute path of the .wasm program file you want to deploy. If your program has an associated configuration file, select y when prompted and paste the JSON string prepared in the previous section. The CLI should submit your program to the network and return a pointer: Program deployed successfully with pointer: 0x7110f20247e9ac29355245e7864cff44066c9a24c0ae303478528645fe542e6e Deploying from account: 5DSUAf2DwxW2ebZq15Pm6Z3SJ69Ur8fGd8ytWvgxvNjYtr7c   You can now interact with your program using the program pointer.  ","version":"Next","tagName":"h3"},{"title":"List deployed programs​","type":1,"pageTitle":"Deploy a program","url":"/guides/deploy-a-program#list-deployed-programs","content":" If you've lost your program pointer, you can list it by running the following:  Start the CLI by running entropy. At the main menu within the CLI, select Deploy Program: ? Select Action Manage Accounts Balance Register Sign Transfer &gt; Deploy Program User Programs Exit Select Get Owned Programs. The CLI will output all the programs deployed by the currently selected account: Retrieved program pointers: [ '0xe80c83dd6597c15de5979c6dc0164ebeb626f3da8e6e03f3345146064938fab4', '0x7110f20247e9ac29355245e7864cff44066c9a24c0ae303478528645fe542e6e' ]   ","version":"Next","tagName":"h3"},{"title":"Troubleshooting​","type":1,"pageTitle":"Deploy a program","url":"/guides/deploy-a-program#troubleshooting","content":" No such file or directory: this indicates that you have given the CLI a path to a .wasm file that either does not exist or the CLI does not have permission to read from. Confirm that the path is correct and that the CLI has permission to read from that file. ","version":"Next","tagName":"h2"},{"title":"Networks","type":0,"sectionRef":"#","url":"/reference/networks","content":"","keywords":"","version":"Next"},{"title":"Mainnet​","type":1,"pageTitle":"Networks","url":"/reference/networks#mainnet","content":" The Entropy main network (mainnet) has not been released yet. Details of mainnet will be available here shortly before launch.  ","version":"Next","tagName":"h2"},{"title":"Testnet​","type":1,"pageTitle":"Networks","url":"/reference/networks#testnet","content":" There is one public testnet available for developers to use. This is not a production network; it will reset frequently.  ","version":"Next","tagName":"h2"},{"title":"Public endpoints​","type":1,"pageTitle":"Networks","url":"/reference/networks#public-endpoints","content":" testnet.entropy.xyz   ","version":"Next","tagName":"h3"},{"title":"Chain details​","type":1,"pageTitle":"Networks","url":"/reference/networks#chain-details","content":" Blocktime: 6 secondsRegistration time: ~30 secondsTime to signature: ~3 seconds when the network is under a light load. Further testing is needed to determine the upper limit under a heavy network load.Expected reset frequency: there is no planned reset schedule. However, this network should be treated as unstable, as resets may happen periodically. An announcement will be made on the Entropy Discord server as to when a reset will occur.  ","version":"Next","tagName":"h3"},{"title":"Resources​","type":1,"pageTitle":"Networks","url":"/reference/networks#resources","content":" Block explorers: at this time, developers should use the default Polkadot.js blockchain explorer.  ","version":"Next","tagName":"h3"},{"title":"Devnet​","type":1,"pageTitle":"Networks","url":"/reference/networks#devnet","content":" Developer networks (devnets) are local test networks available for developers to quickly test their Entropy programs and workflows. The details of these devnets depend on how they are set up by the developer. ","version":"Next","tagName":"h2"},{"title":"Get funds","type":0,"sectionRef":"#","url":"/guides/get-funds","content":"","keywords":"","version":"Next"},{"title":"Mainnet​","type":1,"pageTitle":"Get funds","url":"/guides/get-funds#mainnet","content":" The Entropy main network (mainnet) has yet to be released; as such, mainnet funds are not available.  ","version":"Next","tagName":"h2"},{"title":"Testnet​","type":1,"pageTitle":"Get funds","url":"/guides/get-funds#testnet","content":" Funds for testing are available from the manual faucet.  note We're currently publically testing some of the Entropy tooling. As such, some of the workflows, like getting test funds, are a bit rough. We're building an automated faucet to hand out test funds, and we'll update this page when it's ready.  Log into your GitHub account and go to github.com/entropyxyz/community. Navigate to the Discussions tab and select New discussion. Next to Get Test Funds click Get started: In the Title field, enter the address you copied from the previous section. Enter any text into the Description field; GitHub doesn't allow users to leave this field blank. If you need more than 10,000 test funds, enter the amount of funds you need and a reason why into this field. Click Start discussion.  At this point, someone from Entropy will send you some test funds. This should happen within a couple of hours, but may be longer. Once they've sent the funds to the address you provided they'll let you know, and close the issue. ","version":"Next","tagName":"h2"},{"title":"Use the explorer","type":0,"sectionRef":"#","url":"/guides/use-the-explorer","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Use the explorer","url":"/guides/use-the-explorer#prerequisites","content":" Docker  ","version":"Next","tagName":"h2"},{"title":"Run the explorer​","type":1,"pageTitle":"Use the explorer","url":"/guides/use-the-explorer#run-the-explorer","content":" Open a terminal window and run: docker run --rm -it --name polkadot-ui -e WS_URL=wss://testnet.entropy.xyz -p 80:80 jacogr/polkadot-js-apps:latest This command will start a background process. Open a browser and go to http://localhost.  ","version":"Next","tagName":"h2"},{"title":"Connect to the Entropy network​","type":1,"pageTitle":"Use the explorer","url":"/guides/use-the-explorer#connect-to-the-entropy-network","content":" With the explorer running, select the Unknown dropdown at the top left: In the sidebar, select the Development dropdown. Within the custom endpoint field, enter the address for the network you want to connect to: # Testnet wss://testnet.entropy.xyz Click the Save icon next to the address field. The block explorer should start populating with details from the Entropy network:  You should now be able to use the block explorer as usual. Check out the wiki for details on what information you can get from this blockchain explorer. ","version":"Next","tagName":"h2"},{"title":"Software Development Kit","type":0,"sectionRef":"#","url":"/reference/sdk","content":"Software Development Kit Source code","keywords":"","version":"Next"},{"title":"Manage accounts","type":0,"sectionRef":"#","url":"/guides/manage-accounts","content":"","keywords":"","version":"Next"},{"title":"CLI​","type":1,"pageTitle":"Manage accounts","url":"/guides/manage-accounts#cli","content":" The CLI has a built-in account manager. This is useful for running quick, one-time transactions. The CLI account manager can also be helpful for testing purposes.  You need to have the Entropy CLI installed. Take a look at the CLI page for details on how to install the CLI.  ","version":"Next","tagName":"h2"},{"title":"Create an account​","type":1,"pageTitle":"Manage accounts","url":"/guides/manage-accounts#create-an-account","content":" Start the CLI by running entropy. Select Manage Accounts. Select New. Type n and press ENTER when asked Would you like to import a key?: ? Would you like to import a key? n Enter the name of your new account. The CLI will output some information about it: New account: { name: Ludleth address: 5HMnksPMRPqsDqyCj31VoQFgpiswsr12bk2YTyfMUEKCm2bv } Type Y and press ENTER to go back to the main menu.  ","version":"Next","tagName":"h3"},{"title":"Import an account​","type":1,"pageTitle":"Manage accounts","url":"/guides/manage-accounts#import-an-account","content":" You can import an account by the seed for the account. Most Substrate-based wallets allow you to export your account information.  Start the CLI by running entropy. Select Manage Accounts. Select New. Type y and press ENTER when asked Would you like to import a key?: ? Would you like to import a key? y Enter your seed. If you specified a path when originally creating the account you want to import, enter it when prompted: path: ____ Enter a name for the account you want to import. The CLI will output some information about your new account: New account: { name: Hawkwood address: 5FLSigC9HGRKVhB9FiEo4Y3koPsNmBmLJbpXg2mp1hXcS59Y type: seed } Type Y and press ENTER to go back to the main menu.  ","version":"Next","tagName":"h3"},{"title":"Export an account​","type":1,"pageTitle":"Manage accounts","url":"/guides/manage-accounts#export-an-account","content":" If you need to export an account that you created in the CLI, follow these steps:  Open your ~/.entropy-cli.config file in a text editor. It should look something like: { &quot;accounts&quot;: [ { &quot;name&quot;: &quot;Andre&quot;, &quot;address&quot;: &quot;5CrFp9txcb5UECpNKsD6DTBsG4cj1z58DA43YikSVeeJqXJR&quot;, &quot;data&quot;: { &quot;debug&quot;: true, &quot;seed&quot;: &quot;0xe7f6d671e3db7b85a8e3e7da1ffd348b6334f7df383604db0d6e12ab8d58430e&quot;, &quot;admin&quot;: { &quot;address&quot;: &quot;5CrFp9txcb5UECpNKsD6DTBsG4cj1z58DA43YikSVeeJqXJR&quot;, &quot;type&quot;: &quot;registration&quot;, &quot;verifyingKeys&quot;: [], &quot;userContext&quot;: &quot;ADMIN_KEY&quot;, &quot;seed&quot;: &quot;0xe7f6d671e3db7b85a8e3e7da1ffd348b6334f7df383604db0d6e12ab8d58430e&quot;, &quot;path&quot;: &quot;&quot;, &quot;pair&quot;: { &quot;address&quot;: &quot;5CrFp9txcb5UECpNKsD6DTBsG4cj1z58DA43YikSVeeJqXJR&quot;, &quot;addressRaw&quot;: { &quot;0&quot;: 34, &quot;1&quot;: 189, &quot;2&quot;: 158, ... The critical part of this JSON object is the seed element: &quot;seed&quot;: &quot;0xe7f6d671e3db7b85a8e3e7da1ffd348b6334f7df383604db0d6e12ab8d58430e&quot;, You can use this seed to import your key into another wallet or import it back into the Entropy CLI using the Import function. All the accounts created in the CLI are stored in the ~/.entropy-cli.config file. Make sure to export the specific account you need.  ","version":"Next","tagName":"h3"},{"title":"Subkey​","type":1,"pageTitle":"Manage accounts","url":"/guides/manage-accounts#subkey","content":" Subkey is a command line utility created by Parity Technologies and allows generating and restoring keys for Substrate-based chains, such as Entropy. It provides a few sub-commands to generate keys, check keys, sign messages, verify messages,  ","version":"Next","tagName":"h2"},{"title":"Install Subkey​","type":1,"pageTitle":"Manage accounts","url":"/guides/manage-accounts#install-subkey","content":" The easiest way to start using Subkey is to use the Docker image supplied by Parity. This method requires that you have Docker installed.  docker run -it --pull=always docker.io/parity/subkey:latest   This should output something like:  latest: Pulling from parity/subkey Digest: sha256:ad9097c83147efde6c79fc913266961d813c1ed451270b72284c0cf80c2092b6 Status: Image is up to date for parity/subkey:latest WARNING: The requested image's platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested Utility for generating and restoring with Substrate keys Usage: subkey &lt;COMMAND&gt; Commands: generate-node-key Generate a random node key, write it to a file or stdout and write the corresponding peer-id to stderr generate Generate a random account inspect Gets a public key and a SS58 address from the provided Secret URI inspect-node-key Load a node key from a file or stdin and print the corresponding peer-id sign Sign a message, with a given (secret) key vanity Generate a seed that provides a vanity address verify Verify a signature for a message, provided on STDIN, with a given (public or secret) key help Print this message or the help of the given subcommand(s) Options: -h, --help Print help -V, --version Print version   You are now ready to use Subkey.  Install with Cargo If you'd prefer to install Subkey using Rust's Cargo framework, check out the official Subkey documentation  ","version":"Next","tagName":"h3"},{"title":"Create an account​","type":1,"pageTitle":"Manage accounts","url":"/guides/manage-accounts#create-an-account-1","content":" You can use the generate command against Subkey to generate a new account. Assuming you have the latest Subkey Docker image ready, run the following:  docker run -it --pull=always docker.io/parity/subkey:latest generate   This should output something like:  Secret phrase `hotel forest jar hover kite book view eight stuff angle legend defense` is account: Secret seed: 0xa05c75731970cc7868a2fb7cb577353cd5b31f62dccced92c441acd8fee0c92d Public key (hex): 0xfec70cfbf1977c6965b5af10a4534a6a35d548eb14580594d0bc543286892515 Account ID: 0xfec70cfbf1977c6965b5af10a4534a6a35d548eb14580594d0bc543286892515 SS58 Address: 5Hpm9fq3W3dQgwWpAwDS2ZHKAdnk86QRCu7iX4GnmDxycrte   You can use these credentials to interact with the Entropy network. ","version":"Next","tagName":"h3"},{"title":"Transfer funds","type":0,"sectionRef":"#","url":"/guides/transfer-funds","content":"","keywords":"","version":"Next"},{"title":"Substrate explorer​","type":1,"pageTitle":"Transfer funds","url":"/guides/transfer-funds#substrate-explorer","content":" ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Transfer funds","url":"/guides/transfer-funds#prerequisites","content":" To transfer funds, you must have the following:  Access to at least 2 Entropy accounts, one of which must have funds.Access to the Polkadot.js explorer.A Polkadot.js compatible browser wallet. This guide uses the Polkadot{.js} Browser Extension as an example.  ","version":"Next","tagName":"h3"},{"title":"Steps​","type":1,"pageTitle":"Transfer funds","url":"/guides/transfer-funds#steps","content":" Import the addresses into the wallet. In the Polkadot{.js} Browser Extension, this can be done by selecting the plus + icon and clicking Import account from pre-existing seed: Start the Substrate explorer and connect to the testnet.entropy.xyz network. Select the Accounts dropdown and click Accounts. A popup should display asking if you want to grant the Substrate Explorer access to your wallet. Click Yes, allow this application access. Click Send on the account that you want to send funds from. Select the account you want to send funds to in the send to address dropdown. Enter the number of tokens you want to send. The minimum number you can send is 10000. Click Make Transfer. Review the details on this confirmation page and click Sign and Submit. Enter your password if prompted, and click Sign the transaction.  That's it! The transaction will take up to 6 seconds to transfer funds from one account to another.  ","version":"Next","tagName":"h3"},{"title":"CLI​","type":1,"pageTitle":"Transfer funds","url":"/guides/transfer-funds#cli","content":" You must have the Entropy CLI installed on your machine in order to transfer funds with this method. Check out the installation instructions for more details.  From the main menu in the CLI select Manage Accounts: ? Select Action ❯ Manage Accounts Balance Register Sign Transfer Deploy Program User Programs Exit Choose Select Accounts. Select the account you want to transfer funds from. Return to the main menu. Select Transfer. Enter the amount of funds you want to transfer. Enter the address that you want to transfer funds to.  The transfer should take about 10 seconds.  ","version":"Next","tagName":"h2"},{"title":"SDK​","type":1,"pageTitle":"Transfer funds","url":"/guides/transfer-funds#sdk","content":" The feature is not currently available in the SDK. To track the progress of this upcoming guide, see issue #81 in the Entropy Docs repository. ","version":"Next","tagName":"h2"},{"title":"Command-line interface","type":0,"sectionRef":"#","url":"/reference/cli","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#install","content":" Follow these steps to install Entropy globally using NPM:  Ensure you have Node.js version 20.9.0 or above: node --version v22.2.0 Install the Entropy CLI globally using NPM: npm install --global @entropyxyz/cli You can now run the CLI anywhere using entropy: entropy ? Select Action (Use arrow keys) ❯ Manage Accounts Balance Register Sign Transfer Deploy Program User Programs Exit   ","version":"Next","tagName":"h2"},{"title":"Functions​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#functions","content":" The following functions are available in the CLI.  ","version":"Next","tagName":"h2"},{"title":"Manage Accounts​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#manage-accounts","content":" Create a new Entropy account to store locally. List all Entropy accounts stored locally. Import an account into the CLI using a seed.  &gt; Create/Import Account Select Account List Accounts   Create or Import Account​  Create a new Entropy account or import an existing account using a seed.  Select Account​  Select an account to use within other functions. This is relevant if you have multiple accounts.  For example, assume you have three accounts, and you want to check the balance of account 2. You would:  Start the CLI. Navigate to Manage Accounts. Navigate to Select Account. Choose the account that you would like to select and use within other functions: ? Choose account: (Use arrow keys) &gt; Gael (5CrFp9txcb5UECpNKsD6DTBsG4cj1z58DA43YikSVeeJqXJR) Argo (5Dcps2RdXPQfiJBxxDnrF8iDzDHcnZC8rb5mcJ3xicqzhYbv) Lapp (5G92hBs4UfZpVFYtBmmN3UqPTzGgotq7PSA3XfBMALfvWDUb) The account you select is what the CLI will use when running other functions.  List Accounts​  Show all the locally stored accounts. This function shows secret details such as seed in plaintext.  ","version":"Next","tagName":"h3"},{"title":"Balance​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#balance","content":" Get the balance of an account. You can select any of the accounts stored locally or enter an Entropy address.  ? Select Action Balance Address 5Dcps2RdXPQfiJBxxDnrF8iDzDHcnZC8rb5mcJ3xicqzhYbv has a balance of: 382000000000000 bits ? Return to main menu? (Y/n)   ","version":"Next","tagName":"h3"},{"title":"Register​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#register","content":" Register a locally stored account with the Entropy network.  Attempting to register the address: 5Dcps2RdXPQfiJBxxDnrF8iDzDHcnZC8rb5mcJ3xicqzhYbv Your address 5Dcps2RdXPQfiJBxxDnrF8iDzDHcnZC8rb5mcJ3xicqzhYbv has been successfully registered.   The selected account must have available funds. Each registration costs about 400000000 bits.  ","version":"Next","tagName":"h3"},{"title":"Transfer​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#transfer","content":" Transfer funds from a locally stored account to any other valid Entropy address.  ? Select Action Transfer ? Input amount to transfer: 12345 ? Input recipient's address: 5G92hBs4UfZpVFYtBmmN3UqPTzGgotq7PSA3XfBMALfvWDUb Transferring Funds |++++___________________| 22%   The amount to transfer value is in whole units, not bits. So transferring 1 would equal 10000000000 bits.  ","version":"Next","tagName":"h3"},{"title":"Sign​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#sign","content":" Sign a message using a registered account.  ? Choose account: (Use arrow keys) aragon (5FTwtSAjnKFybzkAKvyEo7owikXcHXmwzN7MzjwDNKEbjkub) &gt; charlie (5Ck5SLSHYac6WFt5UZRSsdJjwmpSZq85fd5TRNAdZQVzEAPT) Other   ","version":"Next","tagName":"h3"},{"title":"In Development​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#in-development","content":" The following functions are currently in development and may not currently work as intended.  ","version":"Next","tagName":"h2"},{"title":"Deploy Program​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#deploy-program","content":" Deploy a program from a locally stored account.  ? Select Action Deploy Program ? Select your action: (Use arrow keys) &gt; Deploy Get Program Pointers Exit   ","version":"Next","tagName":"h3"},{"title":"User Programs​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#user-programs","content":" View all programs deployed to the network from locally stored accounts.  ? Select Action User Programs ? What would you like to do? (Use arrow keys) &gt; View My Programs Add a Program to My List Remove a Program from My List Check if Program Exists Exit to Main Menu   ","version":"Next","tagName":"h3"},{"title":"Troubleshooting​","type":1,"pageTitle":"Command-line interface","url":"/reference/cli#troubleshooting","content":" Here are some common problems you could encounter and how to get around them.  How do I quit the CLI?​  Press CTRL + c at any point to exit the CLI program, even if you're within a function:  ? Select Action Transfer ? Input amount to transfer: 1000 ? Input recipient's address: &lt;----- Pressed `CTRL` + `c` here. user@computer: $   ERR::: RpcError: 1010: Invalid Transaction: Inability to pay some fees , e.g. account balance too low​  This likely means that you don't have enough funds in the selected account to complete that function. Double-check that you've selected the correct account and that the account has enough funds in it. If you need more test funds, head over to the faucet for more.  CLI crashes when registering​  You may encounter the following error when registering:  2024-06-05 00:11:42 REGISTRY: Unknown signed extensions ValidateConfirmRegistered found, treating them as no-effect 2024-06-05 00:11:42 API/INIT: RPC methods not decorated: chainSpec_v1_chainName, chainSpec_v1_genesisHash, chainSpec_v1_properties Attempting to register the address: 5Dcps2RdXPQfiJBxxDnrF8iDzDHcnZC8rb5mcJ3xicqzhYbv /root/cli/src/config/index.ts:21 return JSON.parse(configBuffer.toString()) ^ SyntaxError: Unexpected end of JSON input at JSON.parse (&lt;anonymous&gt;) at Object.get (/root/cli/src/config/index.ts:21:15) at async EventEmitter.&lt;anonymous&gt; (/root/cli/src/common/initializeEntropy.ts:102:23)   This is a bug that the Entropy team are aware of, and are working on a fix. In the meantime, restart the CLI and try to register that account again. If it keep failing, please raise an issue in the Entropy CLI repository. ","version":"Next","tagName":"h2"},{"title":"Rust Testing Interface","type":0,"sectionRef":"#","url":"/reference/rust-testing-interface","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Rust Testing Interface","url":"/reference/rust-testing-interface#prerequisites","content":" To run the RTI, you will need the following packages installed:  OpenSSL: # Debian/Ubuntu sudo apt install libssl-dev # MacOS brew install openssl The pkg-config tool: # Debian/Ubuntu sudo apt install pkg-config # MacOS brew install pkg-config Rust: # Any Unix-based operating system: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh   ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Rust Testing Interface","url":"/reference/rust-testing-interface#installation","content":" Install the RTI using the pre-build crate through Cargo:  cargo install entropy-test-cli   Updating crates.io index Downloaded entropy-test-cli v0.1.0 ... Installed package `entropy-test-cli v0.1.0` (executable `entropy-test-cli`)   ","version":"Next","tagName":"h2"},{"title":"Environment variables​","type":1,"pageTitle":"Rust Testing Interface","url":"/reference/rust-testing-interface#environment-variables","content":" You can use the following environment variables to make using the RTI easier:  Variable\tDescription\tExampleENTROPY-MNEMONIC\tThe mnemonic of the account you'd like to use when interacting with the RTI.\tENTROPY_MNEMONIC='choice square dance because into glance hazard return cram host snap deer' ENTROPY_DEVNET\tThe specific chain-endpoint you want to use when interacting with the RTI.\tENTROPY_DEVNET='wss://testnet.entropy.xyz'  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Rust Testing Interface","url":"/reference/rust-testing-interface#usage","content":" ","version":"Next","tagName":"h2"},{"title":"Register​","type":1,"pageTitle":"Rust Testing Interface","url":"/reference/rust-testing-interface#register","content":" Register an account with the Entropy network and create keyshares.  Usage​  entropy-test-cli register &lt;MNEMONIC&gt; [KEY_VISIBILITY] [PROGRAMS]   Example​  entropy-test-cli --chain-endpoint=&quot;wss://testnet.entropy.xyz&quot; register &quot;image point raccoon steak champion clown adult until hamster sun army year&quot;   ","version":"Next","tagName":"h3"},{"title":"Status​","type":1,"pageTitle":"Rust Testing Interface","url":"/reference/rust-testing-interface#status","content":" Display a list of registered Entropy accounts.  Usage​  entropy-test-cli status   Example​  entropy-test-cli --chain-endpoint=&quot;wss://testnet.entropy.xyz&quot; status   ","version":"Next","tagName":"h3"},{"title":"Sign​","type":1,"pageTitle":"Rust Testing Interface","url":"/reference/rust-testing-interface#sign","content":" Ask the network to sign a given message.  Usage​  entropy-test-cli sign &lt;SIGNATURE_VERIFYING_KEY&gt; &lt;MESSAGE&gt; [AUXILARY_DATA]   Example​  entropy-test-cli --chain-endpoint=&quot;wss://testnet.entropy.xyz&quot; sign &quot;0x1ca639d1cae8ea4e4bd37f972999e0e140866614b621bc09950ceb469b987e27&quot; &quot;Good morning.&quot;   ","version":"Next","tagName":"h3"},{"title":"Store program​","type":1,"pageTitle":"Rust Testing Interface","url":"/reference/rust-testing-interface#store-program","content":" Store a given program on-chain.  Usage​  entropy-test-cli store-program &lt;MNEMONIC&gt; [PROGRAM_FILE] [CONFIG_INTERFACE_FILE] [AUX_DATA_INTERFACE_FILE]   Example​  entropy-test-cli --chain-endpoint=&quot;wss://testnet.entropy.xyz&quot; store-program &quot;image point raccoon steak champion clown adult until hamster sun army year&quot; ./program.wasm ./interface-file.config ./aux-data.config   ","version":"Next","tagName":"h3"},{"title":"Update programs​","type":1,"pageTitle":"Rust Testing Interface","url":"/reference/rust-testing-interface#update-programs","content":" Update the program for a particular account.  Usage​  entropy-test-cli update-programs &lt;SIGNATURE_VERIFYING_KEY&gt; &lt;MNEMONIC&gt; [PROGRAMS]   Example​  entropy-test-cli --chain-endpoint=&quot;wss://testnet.entropy.xyz&quot; update-programs &quot;0x1ca639d1cae8ea4e4bd37f972999e0e140866614b621bc09950ceb469b987e27&quot; &quot;image point raccoon steak champion clown adult until hamster sun army year&quot; ./programs  ","version":"Next","tagName":"h3"},{"title":"Spin up a devnet","type":0,"sectionRef":"#","url":"/guides/spin-up-a-devnet","content":"","keywords":"","version":"Next"},{"title":"Docker image​","type":1,"pageTitle":"Spin up a devnet","url":"/guides/spin-up-a-devnet#docker-image","content":" Spinning up a devnet using the Docker images supplied in the Entropy Core repo is the easiest way to get up and running. The requirements are fairly minimal, and everything should work straight out of the box.  ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Spin up a devnet","url":"/guides/spin-up-a-devnet#prerequisites","content":" You need to have Docker and Docker Compose installed. Verify you have them both installed by running:  docker version &amp;&amp; docker compose version   Client: Cloud integration: v1.0.35+desktop.13 Version: 26.1.1 ... Docker Compose version v2.27.0-desktop.2   ","version":"Next","tagName":"h3"},{"title":"Steps​","type":1,"pageTitle":"Spin up a devnet","url":"/guides/spin-up-a-devnet#steps","content":" Clone the Entropy Core repository and move into the new entropy-core directory: git clone https://github.com/entropyxyz/entropy-core.git cd entropy-core Add the Alice and Bob threshold-signing services (TSS) to your local hosts file: echo &quot;127.0.0.1\talice-tss-server bob-tss-server&quot; | sudo tee -a /etc/hosts You may need to enter your computer's password when prompted. Start the Docker containers: docker compose up --detach # Detaching is optional. [+] Running 0/17 ⠸ bob-tss-server [⠀] Pulling ⠏ b3d3cc4a5268 Waiting ⠏ dec0c2d4580b Waiting ... ✔ Container entropy-devnet-local-bob-chain-node-1 Started ✔ Container entropy-devnet-local-alice-tss-server-1 Started ✔ Container entropy-devnet-local-bob-tss-server-1 Started Confirm that the containers are up and running: docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 23116711e503 entropyxyz/entropy-tss &quot;/usr/local/bin/entr…&quot; 1 minutes ago Up 4 seconds 9615/tcp, 9944/tcp, 127.0.0.1:3001-&gt;3001/tcp, 30333/tcp entropy-devnet-local-alice-tss-server-1 c83c2ae9da20 entropyxyz/entropy &quot;/usr/local/bin/entr…&quot; 1 minutes ago Up 4 seconds 3001/tcp, 9615/tcp, 30333/tcp, 127.0.0.1:9944-&gt;9944/tcp entropy-devnet-local-alice-chain-node-1 5088bb75951c entropyxyz/entropy-tss &quot;/usr/local/bin/entr…&quot; 1 minutes ago Up 4 seconds 3001/tcp, 9615/tcp, 9944/tcp, 30333/tcp, 127.0.0.1:3002-&gt;3002/tcp entropy-devnet-local-bob-tss-server-1 3b0048bcaa00 entropyxyz/entropy &quot;/usr/local/bin/entr…&quot; 1 minutes ago Up 4 seconds 3001/tcp, 9615/tcp, 30333/tcp, 127.0.0.1:9945-&gt;9944/tcp entropy-devnet-local-bob-chain-node-1 Confirm that the local devnet is functioning by using the Rust test interface within the Entropy Core repo: cargo run -p entropy-test-cli -- --chain-endpoint=&quot;ws://127.0.0.1:9944&quot; status Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s Running `target/debug/entropy-test-cli '--chain-endpoint=ws://127.0.0.1:9944' status` ... Hash Stored by: Times used: Size in bytes: Configurable? Has auxiliary? 0x0000…0000 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY 10 300498 true true Success: Got status That took 224.958542ms If this is the first time you are running the Rust testing interface, the cargo command above will take a few minutes to complete. You can also verify that things are working as expected by checking the server logs: docker compose logs alice-chain-node-1 | 2024-06-24 19:41:06 Unexpected status code: 204 alice-chain-node-1 | 2024-06-24 19:41:06 💤 Idle (1 peers), best: #116 (0xd68c…bfed), finalized #113 (0x06df…be36), ⬇ 0.6kiB/s ⬆ 0.6kiB/s alice-chain-node-1 | 2024-06-24 19:41:11 💤 Idle (1 peers), best: #116 (0xd68c…bfed), finalized #114 (0xb994…0299), ⬇ 0.6kiB/s ⬆ 0.5kiB/s You can now interact with this local devnet using the CLI or SDK. To stop the network, simply use the docker stop command followed by the ID of each Docker container: docker stop $(docker ps -a -q) 23116711e503 c83c2ae9da20 5088bb75951c 3b0048bcaa00 Alternatively, you can stop each container individually. docker stop 23116711 docker stop c83c2... ... That's it!  ","version":"Next","tagName":"h3"},{"title":"Build from source​","type":1,"pageTitle":"Spin up a devnet","url":"/guides/spin-up-a-devnet#build-from-source","content":" It is possible to build the chain node and threshold-signature scheme server binaries. However, the process for spinning up a devnet with this method is slightly more involved than the Docker method outlined above. We recommend that you only follow this method if you have a specific reason to not run Docker.  ","version":"Next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Spin up a devnet","url":"/guides/spin-up-a-devnet#prerequisites-1","content":" You must have the latest LTS version of Rust installed, along with all the Substrate dependencies for your operating system.  ","version":"Next","tagName":"h3"},{"title":"Steps​","type":1,"pageTitle":"Spin up a devnet","url":"/guides/spin-up-a-devnet#steps-1","content":" Clone the Entropy Core repository and move into the new entropy-core directory: git clone https://github.com/entropyxyz/entropy-core.git cd entropy-core Build the chain node and threshold signature scheme server binaries: cargo build --release Downloaded asn1-rs-derive v0.4.0 Downloaded byte-tools v0.3.1 Downloaded const-random-macro v0.1.16 ... Cargo is downloading and compiling a lot of tooling for the binaries. This process may take upwards of 10 minutes, depending on your system. Run the node binary: ./target/release/entropy --dev --rpc-external 2024-06-24 18:36:10 💤 Idle (0 peers), best: #4 (0xe3da…d11b), finalized #0 (0xe938…3b8f), ⬇ 0 ⬆ 0 2024-06-24 18:36:12 🙌 Starting consensus session on top of parent 0xe3da43079cb427b60ca77cee0fe206b933ec9df57ece549ad46a5681ea95d11b 2024-06-24 18:36:12 🎁 Prepared block for proposing at 5 (2 ms) [hash: 0x636c606f7d66d8c25bc64956c14b1a9c209d035279ff4f7dccd629c346d81047; parent_hash: 0xe3da…d11b; extrinsics (1): [0x7f45…6999 Confirm that the local devnet is functioning by using the Rust test interface within the Entropy Core repo: cargo run -p entropy-test-cli -- --chain-endpoint=&quot;ws://127.0.0.1:9944&quot; status Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.83s Running `target/debug/entropy-test-cli '--chain-endpoint=ws://127.0.0.1:9944' status` ... Hash Stored by: Times used: Size in bytes: Configurable? Has auxiliary? 0x0000…0000 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY 10 300498 true true Success: Got status That took 182.155ms If this is the first time you are running the Rust testing interface, the cargo command above will take a few minutes to complete. That's it!  ","version":"Next","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Spin up a devnet","url":"/guides/spin-up-a-devnet#best-practices","content":" It's important to regularly reset the network to maintain a clean testing environment, thoroughly document all configuration settings for reproducibility, and simulate various network conditions to ensure robustness.  Developers should strive to mirror the mainnet environment as closely as possible while still maintaining flexibility for rapid iteration. If you plan to share access to the devnet, it's essential to establish a clear protocol for managing and distributing test tokens, implement monitoring and logging systems to track network behaviour, and regularly update the devnet software to match planned mainnet upgrades.  ","version":"Next","tagName":"h2"},{"title":"Troubleshooting​","type":1,"pageTitle":"Spin up a devnet","url":"/guides/spin-up-a-devnet#troubleshooting","content":" Cannot connect to the Docker daemon: If you see the error message Cannot connect to the Docker daemon at unix:///Users/johnny/.docker/run/docker.sock. Is the docker daemon running? it's likely because your Docker daemon isn't running. Double-check that you've opened the Docker application.  I can't build from source: there are quite a few dependencies for building Substrate-based nodes. Run through the official Substrate documentation and make sure you have everything installed. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}